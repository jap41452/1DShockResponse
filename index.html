<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>1D Shock Response</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<style>
  :root{
    --w: 920px;
    --border:#9aa4b2;
    --panel:#d9d9d9;
    --ink:#0b1220;
    --red:#c00000;
  }
  body{ margin:0; background:#fff; font-family: Arial, Helvetica, sans-serif; color:var(--ink); }
  .wrap{
    width: min(var(--w), calc(100vw - 16px));
    margin: 10px auto 18px;
    border:1px solid var(--border);
    background: var(--panel);
  }
  .topbar{
    display:grid;
    grid-template-columns: 1fr 1fr;
    align-items:center;
    padding:6px 10px;
    background:#cfcfcf;
    border-bottom:1px solid var(--border);
    font-weight:700;
    font-size:14px;
  }
  .topbar .r{ text-align:center; }

  .upper{
    display:grid;
    grid-template-columns: 260px 250px 1fr;
    gap:6px;
    padding:10px;
  }

  .rows{
    display:grid;
    grid-template-columns: 40px 1fr;
    row-gap:8px;
    column-gap:10px;
    align-items:center;
    font-size:13px;
  }
  .lab{ display:flex; align-items:center; gap:6px; }
  .tri{
    width:0;height:0;
    border-left:7px solid transparent;
    border-top:7px solid var(--red);
    transform: rotate(45deg);
    margin-left:2px;
  }
  input, select{
    width:100%;
    height:22px;
    padding:2px 6px;
    font-size:13px;
    border:1px solid #333;
    background:#fff;
    box-sizing:border-box;
  }
  select{ padding:1px 4px; }

  .summaryRows{
    display:grid;
    grid-template-columns: 1fr 1fr;
    row-gap:8px;
    column-gap:10px;
    align-items:center;
    font-size:13px;
  }
  .sumLab{ display:flex; align-items:center; gap:6px; }
  .sumVal{ font-weight:700; }

  .schem{
    background: var(--panel);
    display:flex;
    justify-content:center;
    align-items:flex-start;
  }
  canvas#schem{
    width: 340px;
    height: 220px;
    background: var(--panel);
  }

  .controls{
    padding: 0 10px 8px;
    display:flex;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;
  }
  .btn{
    height:24px;
    padding:0 10px;
    border:1px solid #333;
    background:#f2f2f2;
    font-weight:700;
    font-size:12px;
    cursor:pointer;
  }
  .btn:disabled{ opacity:.55; cursor:not-allowed; }

  .ctl{
    display:flex;
    align-items:center;
    gap:8px;
    font-size:12px;
    margin-left:auto;
  }
  input[type="range"]{ height:auto; }

  .plotWrap{
    background:#fff;
    border-top:1px solid var(--border);
    padding:8px 10px 10px;
  }
  .plotBox{
    background:#fff;
    border:1px solid #333;
    padding:6px;
  }
  #chart{ width:100%; height:290px; }

  .hint{
    padding: 0 10px 8px;
    font-size:11px;
    opacity:.8;
    margin-top:12px;
    line-height:1.25;
  }

  /* PSD panel shown only for Random */
  .psdPanel{
    display:none;
    margin-top:10px;
    padding:8px;
    border:1px solid #333;
    background:#efefef;
  }
  .psdTitle{
    font-size:12px;
    font-weight:700;
    margin-bottom:6px;
  }
  .psdTbl{
    width:100%;
    border-collapse:collapse;
    font-size:12px;
  }
  .psdTbl th, .psdTbl td{
    border:1px solid #333;
    padding:3px 4px;
    background:#fff;
  }
  .psdTbl th{
    background:#dedede;
    font-weight:700;
    text-align:center;
  }
  .psdTbl input{
    height:20px;
    font-size:12px;
    border:1px solid #333;
  }
  .psdBtnRow{
    display:flex;
    gap:8px;
    margin-top:8px;
    align-items:center;
  }
  .psdNote{
    font-size:11px;
    opacity:.85;
    line-height:1.25;
  }

  @media (max-width: 860px){
    .upper{ grid-template-columns: 1fr; }
    canvas#schem{ width: 360px; height: 240px; }
    .ctl{ margin-left:0; }
  }
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div>1D Shock Response</div>
    <div class="r">XL4sim</div>
  </div>

  <div class="upper">
    <!-- Inputs -->
    <div>
      <div class="rows" style="padding:4px 2px 0;">
        <div class="lab"><div style="width:18px;text-align:right;font-weight:700;">W</div><div class="tri"></div></div>
        <div><input id="W" type="number" step="any" value="10"></div>

        <div class="lab"><div style="width:18px;text-align:right;font-weight:700;">k</div><div class="tri"></div></div>
        <div><input id="k" type="number" step="any" value="2000"></div>

        <div class="lab"><div style="width:18px;text-align:right;font-weight:700;">c</div><div class="tri"></div></div>
        <div><input id="c" type="number" step="any" value="5"></div>

        <div class="lab"><div style="width:18px;text-align:right;font-weight:700;">g</div><div class="tri"></div></div>
        <div><input id="g" type="number" step="any" value="386.09"></div>

        <div class="lab"><div style="width:18px;text-align:right;font-weight:700;">G<sub>pk</sub></div><div class="tri"></div></div>
        <div><input id="Gpk" type="number" step="any" value="10"></div>

        <div class="lab"><div style="width:18px;text-align:right;font-weight:700;">T<sub>p</sub></div><div class="tri"></div></div>
        <div><input id="Tp" type="number" step="any" value="20"></div>

        <div class="lab"><div style="width:18px;text-align:right;font-weight:700;">&#916;t</div><div class="tri"></div></div>
        <div><input id="dt" type="number" step="any" value="0.05"></div>

        <div class="lab"><div style="width:18px;text-align:right;font-weight:700;">shape</div><div class="tri"></div></div>
        <div>
          <select id="shape">
            <option value="halfSine">1/2 sine</option>
            <option value="triangular">triangular</option>
            <option value="rectangular">rectangular</option>
            <option value="sawtooth">sawtooth</option>
            <option value="random">Random</option>
          </select>
        </div>
      </div>

      <div class="hint">
        Inputs: W, k, c, gravitational constant g, peak shock level G<sub>pk</sub> in g’s,
        pulse duration T<sub>p</sub> in ms (ignored for Random), integration step &#916;t in ms.
      </div>

      <!-- Random PSD panel -->
      <div class="psdPanel" id="psdPanel">
        <div class="psdTitle">Random input PSD (up to 5 points)</div>
        <table class="psdTbl">
          <thead>
            <tr>
              <th style="width:50%">Frequency (Hz)</th>
              <th style="width:50%">PSD (g²/Hz)</th>
            </tr>
          </thead>
          <tbody>
            <!-- 5 rows -->
            <tr><td><input id="f1" type="number" step="any" value="10"></td><td><input id="s1" type="number" step="any" value="0.010"></td></tr>
            <tr><td><input id="f2" type="number" step="any" value="30"></td><td><input id="s2" type="number" step="any" value="0.020"></td></tr>
            <tr><td><input id="f3" type="number" step="any" value="60"></td><td><input id="s3" type="number" step="any" value="0.010"></td></tr>
            <tr><td><input id="f4" type="number" step="any" value=""></td><td><input id="s4" type="number" step="any" value=""></td></tr>
            <tr><td><input id="f5" type="number" step="any" value=""></td><td><input id="s5" type="number" step="any" value=""></td></tr>
          </tbody>
        </table>

        <div class="psdBtnRow">
<button class="btn" id="buildRandom">Build Random g(t)</button>

          <div class="psdNote" id="psdStatus">Provide 2–5 points, increasing frequency. Click “Build Random g(t)” to preview and arm the base input.</div>
        </div>
      </div>
    </div>

    <!-- Summary -->
    <div>
      <div class="summaryRows" style="padding:4px 2px 0;">
        <div class="sumLab"><div style="width:64px;font-weight:700;">f<sub>n</sub></div><div class="tri"></div></div>
        <div class="sumVal" id="fn">—</div>

        <div class="sumLab"><div style="width:64px;font-weight:700;">c<sub>c</sub></div><div class="tri"></div></div>
        <div class="sumVal" id="cc">—</div>

        <div class="sumLab"><div style="width:64px;font-weight:700;">&#950;</div><div class="tri"></div></div>
        <div class="sumVal" id="zeta">—</div>

        <div class="sumLab"><div style="width:110px;font-weight:700;">t stop</div><div class="tri"></div></div>
        <div class="sumVal" id="tStop">—</div>

        <div class="sumLab"><div style="width:110px;font-weight:700;">base g max</div><div class="tri"></div></div>
        <div class="sumVal" id="gmaxB">—</div>

        <div class="sumLab"><div style="width:110px;font-weight:700;">weight g max</div><div class="tri"></div></div>
        <div class="sumVal" id="gmaxW">—</div>
      </div>

      <div class="hint">
        Derived live from inputs. Auto-stop: pulse + 20 response cycles (or Random duration = 20 response cycles).
      </div>
    </div>

    <!-- Schematic -->
    <div class="schem">
      <canvas id="schem" width="520" height="340"></canvas>
    </div>
  </div>

  <div class="controls">
    <button class="btn" id="run">Run</button>
    <button class="btn" id="pause" disabled>Pause</button>
    <button class="btn" id="stop" disabled>Stop</button>
    <button class="btn" id="reset">Reset</button>

    <div class="ctl">
      <div style="font-weight:700;">Animation speed</div>
      <input id="speed" type="range" min="0.1" max="4" step="0.1" value="1.0">
      <div id="speedLbl" style="width:48px;text-align:right;font-weight:700;">1.0×</div>
    </div>
  </div>

  <div class="plotWrap">
    <div class="plotBox">
      <canvas id="chart"></canvas>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const fmt = (x, n=3) => {
    if (!isFinite(x)) return "—";
    const ax = Math.abs(x);
    if (ax >= 1000) return x.toFixed(0);
    if (ax >= 100)  return x.toFixed(1);
    if (ax >= 10)   return x.toFixed(2);
    return x.toFixed(n);
  };
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  const defaults = {
    W:10, k:2000, c:5, g:386.09, Gpk:10, Tp:20, dt:0.05, shape:"halfSine", speed:1.0
  };

  const inp = {
    W: $("W"), k: $("k"), c: $("c"), g: $("g"),
    Gpk: $("Gpk"), Tp: $("Tp"), dt: $("dt"), shape: $("shape")
  };
  



const out = {
    fn: $("fn"), cc: $("cc"), zeta: $("zeta"),
    tStop: $("tStop"), gmaxB: $("gmaxB"), gmaxW: $("gmaxW")
  };

  const psdPanel = $("psdPanel");
  const buildRandomBtn = $("buildRandom");
  const psdStatus = $("psdStatus");

  const btnRun = $("run"), btnPause = $("pause"), btnStop = $("stop"), btnReset = $("reset");
  const speed = $("speed"), speedLbl = $("speedLbl");

  let lastRunInputs = null;

  // Random input cache: generated base acceleration history (g) aligned to dt & tStop
  let randomInput = null; // {t:[], abase:[], dt, tStop, gMaxB, meta:{fmin,fmax,nbins}}

  // Chart
  const chart = new Chart($("chart").getContext("2d"), {
    type: "line",
    data: {
      labels: [],
      datasets: [
        { label: "Base Accel, a_b (g)", data: [], borderWidth: 2, pointRadius: 0, tension: 0.05, yAxisID: "yG" },
        { label: "Weight Accel, a_w (g)", data: [], borderWidth: 2, pointRadius: 0, tension: 0.05, borderDash: [6,4], yAxisID: "yG" }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      interaction: { mode: "index", intersect: false },
      plugins: { legend: { position: "top" } },
      scales: {
        x: { title: { display: true, text: "Time, sec." }, ticks: { maxTicksLimit: 10 } },
        yG: { position: "left", title: { display: true, text: "Acceleration, g's" } }
      }
    }
  });

  // Shock shapes (single pulse 0..Tp), used for non-random
  function shapeVal(s, kind){
    s = clamp(s, 0, 1);
    switch(kind){
      case "halfSine":   return Math.sin(Math.PI*s);
      case "triangular": return (s<=0.5) ? (2*s) : (2*(1-s));
      case "rectangular":return 1;
      case "sawtooth":   return (1 - s);
      default:           return Math.sin(Math.PI*s);
    }
  }
  function baseAccelPulse_g(t, Tp, Gpk, kind){
    if (t < 0 || t > Tp) return 0;
    return Gpk * shapeVal(t/Tp, kind);
  }

  // RK4 for state X=[z, zd, y, yd], where z=x-y
  // m z¨ + c z˙ + k z = -m y¨, with y¨ = a_b(t)
  function rk4Step(t, X, h, pars){
    const {m,c,k,g, abase_g_func} = pars;

    function deriv(tt, XX){
      const z  = XX[0];
      const zd = XX[1];
      const y  = XX[2];
      const yd = XX[3];

      const ab_g = abase_g_func(tt);
      const ab = ab_g * g;

      const zdd = (-c*zd - k*z)/m - ab;
      const ydd = ab;

      return [zd, zdd, yd, ydd];
    }

    const k1 = deriv(t, X);
    const X2 = X.map((xi,i)=>xi + 0.5*h*k1[i]);
    const k2 = deriv(t + 0.5*h, X2);
    const X3 = X.map((xi,i)=>xi + 0.5*h*k2[i]);
    const k3 = deriv(t + 0.5*h, X3);
    const X4 = X.map((xi,i)=>xi + h*k3[i]);
    const k4 = deriv(t + h, X4);

    return X.map((xi,i)=> xi + (h/6)*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i]));
  }

  function computeKPI(){
    const W = +inp.W.value;
    const k = +inp.k.value;
    const c = +inp.c.value;
    const g = +inp.g.value;
    if (!(W>0) || !(k>0) || !(g>0)) return null;

    const m = W/g;
    const wn = Math.sqrt(k/m);
    const fn = wn/(2*Math.PI);
    const cc = 2*m*wn;
    const zeta = (cc>0) ? (c/cc) : 0;
    const Tn = 1/Math.max(1e-12, fn);

    return {W,k,c,g,m,wn,fn,cc,zeta,Tn};
  }

  // ---------- Random PSD utilities ----------
  function readPSDPoints(){
    const rows = [
      {f:+$("f1").value, s:+$("s1").value},
      {f:+$("f2").value, s:+$("s2").value},
      {f:+$("f3").value, s:+$("s3").value},
      {f:+$("f4").value, s:+$("s4").value},
      {f:+$("f5").value, s:+$("s5").value}
    ];

    // keep rows that have both f and s finite
    const pts = rows.filter(r => isFinite(r.f) && isFinite(r.s));

    // must have at least 2 points
    if (pts.length < 2) return {ok:false, msg:"Enter at least 2 PSD points."};

    // validate positivity and increasing frequency
    for (let i=0;i<pts.length;i++){
      if (!(pts[i].f > 0)) return {ok:false, msg:"Frequencies must be > 0."};
      if (!(pts[i].s >= 0)) return {ok:false, msg:"PSD values must be ≥ 0."};
      if (i>0 && !(pts[i].f > pts[i-1].f)) return {ok:false, msg:"Frequencies must be strictly increasing."};
    }
    return {ok:true, pts};
  }

  function interpPSD(f, pts){
    // piecewise linear; clamp outside range to end values
    if (f <= pts[0].f) return pts[0].s;
    if (f >= pts[pts.length-1].f) return pts[pts.length-1].s;
    for (let i=0;i<pts.length-1;i++){
      const f1 = pts[i].f, f2 = pts[i+1].f;
      if (f >= f1 && f <= f2){
        const s1 = pts[i].s, s2 = pts[i+1].s;
        const a = (f - f1)/(f2 - f1);
        return s1 + a*(s2 - s1);
      }
    }
    return 0;
  }

  function buildRandomTimeHistory(kpi){
    // Build base accel history a_b(t) in g from PSD via random-phase sum-of-sinusoids.
    // PSD is in g^2/Hz, frequency in Hz.
    const chk = readPSDPoints();
    if (!chk.ok) return {ok:false, msg:chk.msg};
    const pts = chk.pts;

    const dt_ms = +inp.dt.value;
    if (!(dt_ms>0)) return {ok:false, msg:"Δt must be > 0."};

    // Use same stop rule: 20 response cycles
    const cycles = 20;
    const tStop = cycles * kpi.Tn;

    // enforce a dt that resolves the highest PSD frequency reasonably, and the response
    let dt = dt_ms/1000;
    const fmax = pts[pts.length-1].f;
    // Nyquist: dt <= 1/(2*fmax). For synthesis quality, use ~10–15 points/cycle at fmax.
    const dtNy = 1/(2*fmax + 1e-12);
    const dtQual = 1/(12*fmax + 1e-12);
    dt = Math.min(dt, dtNy, dtQual, kpi.Tn/240);
    dt = Math.max(dt, 1e-6);

    const n = Math.ceil(tStop/dt) + 1;
    const t = new Array(n);

    // Discretize frequency axis into bins and sum
    const nbins = 256;
    const fmin = pts[0].f;
    const fspan = Math.max(1e-9, (fmax - fmin));
    const df = fspan/(nbins-1);

    // precompute bin freqs, amplitudes, phases
    const freqs = new Array(nbins);
    const amps  = new Array(nbins);
    const phs   = new Array(nbins);

    for (let i=0;i<nbins;i++){
      const fi = fmin + i*df;
      const Si = Math.max(0, interpPSD(fi, pts)); // g^2/Hz
      // amplitude per bin for one-sided PSD approximation:
      // a(t) = Σ sqrt(2*S(fi)*df) cos(2π fi t + φi)
      freqs[i] = fi;
      amps[i]  = Math.sqrt(2*Si*df);
      phs[i]   = 2*Math.PI*Math.random();
    }

    const abase = new Array(n);
    let gMaxB = 0;

    for (let k=0;k<n;k++){
      const tt = k*dt;
      t[k] = tt;
      let val = 0;
      for (let i=0;i<nbins;i++){
        val += amps[i]*Math.cos(2*Math.PI*freqs[i]*tt + phs[i]);
      }
      abase[k] = val; // g
      gMaxB = Math.max(gMaxB, Math.abs(val));
    }

    return {ok:true, t, abase, dt, tStop, gMaxB, meta:{fmin,fmax,nbins,df}};
  }

  function abaseFromRandom(tt){
    if (!randomInput) return 0;
    const dt = randomInput.dt;
    const a = randomInput.abase;
    const n = a.length;
    if (tt <= 0) return a[0];
    const idx = tt/dt;
    const i0 = Math.floor(idx);
    if (i0 >= n-1) return a[n-1];
    const f = idx - i0;
    return a[i0]*(1-f) + a[i0+1]*f;
  }

  // ---------- Simulation ----------
  function simulateFromInputs(){
    const kpi = computeKPI();
    if (!kpi) return null;

    const {W,k,c,g,m,fn,cc,zeta,Tn} = kpi;

    const shape = inp.shape.value;
    const Gpk = +inp.Gpk.value;
    const Tp_ms = +inp.Tp.value;
    const dt_ms = +inp.dt.value;

    if (!(dt_ms>0)) return null;

    const cycles = 20;
    let tStop = 0;
    let dt = dt_ms/1000;

    let abase_g_func = null;

    if (shape === "random"){
      if (!randomInput){
        return {__needsRandom:true, kpi}; // signal caller
      }
      // Force simulation time grid to align with generated random input dt for consistency
      dt = randomInput.dt;
      tStop = randomInput.tStop;
      abase_g_func = abaseFromRandom;
    } else {
      const Tp = (Tp_ms>0) ? (Tp_ms/1000) : 0.02;
      // Limit dt to resolve both pulse and response
      dt = Math.max(1e-6, Math.min(dt, Tp/60, Tn/240));
      tStop = Tp + cycles*Tn;

      abase_g_func = (tt)=>baseAccelPulse_g(tt, Tp, Gpk, shape);
    }

    const n = Math.ceil(tStop/dt) + 1;

    const t = new Array(n);
    const z = new Array(n);
    const zd = new Array(n);
    const y = new Array(n);
    const yd = new Array(n);
    const abase = new Array(n);
    const aweight = new Array(n);

    // ICs: at rest
    let X = [0,0,0,0];
    let tt = 0;

    let gMaxB = 0;
    let gMaxW = 0;

    for(let i=0;i<n;i++){
      const zi  = X[0];
      const zdi = X[1];

      const ab_g = abase_g_func(tt);
      const ab = ab_g * g;

      const zdd = (-c*zdi - k*zi)/m - ab;
      const xdd = zdd + ab;

      t[i]=tt;
      z[i]=zi; zd[i]=zdi;
      y[i]=X[2]; yd[i]=X[3];

      abase[i]=ab_g;
      aweight[i]=xdd/g;

      gMaxB = Math.max(gMaxB, Math.abs(ab_g));
      gMaxW = Math.max(gMaxW, Math.abs(aweight[i]));

      X = rk4Step(tt, X, dt, {m,c,k,g, abase_g_func});
      tt += dt;
    }

    return {W,k,c,g,Gpk, Tp_ms, dt, shape, m, fn, cc, zeta, Tn, tStop, t,z,zd,y,yd, abase, aweight, gMaxB, gMaxW};
  }

  function writeSummary(sim){
    if (!sim || sim.__needsRandom){
      const kpi = sim && sim.kpi ? sim.kpi : computeKPI();
      if (!kpi){
        out.fn.textContent="—"; out.cc.textContent="—"; out.zeta.textContent="—";
        out.tStop.textContent="—"; out.gmaxB.textContent="—"; out.gmaxW.textContent="—";
        return;
      }
      out.fn.innerHTML   = fmt(kpi.fn,3) + " Hz";
      out.cc.textContent = fmt(kpi.cc,3);
      out.zeta.innerHTML = fmt(kpi.zeta*100,1) + " %";
      out.tStop.textContent = fmt(20*kpi.Tn,3) + " s";
      out.gmaxB.innerHTML = (randomInput ? fmt(randomInput.gMaxB,2) + " g" : "—");
      out.gmaxW.innerHTML = "—";
      return;
    }

    out.fn.innerHTML   = fmt(sim.fn,3) + " Hz";
    out.cc.textContent = fmt(sim.cc,3);
    out.zeta.innerHTML = fmt(sim.zeta*100,1) + " %";
    out.tStop.textContent = fmt(sim.tStop,3) + " s";
    out.gmaxB.innerHTML = fmt(sim.gMaxB,2) + " g";
    out.gmaxW.innerHTML = fmt(sim.gMaxW,2) + " g";
  }

  // ---------- Schematic (grounded base, relative motion) ----------
  const canv = $("schem");
  const ctx = canv.getContext("2d");

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
  }
  function drawSpring(x, yTop, yBot){
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 2;
    const turns = 9, amp = 14;
    const dy = yBot - yTop;
    const seg = dy / (turns*2);
    ctx.beginPath();
    ctx.moveTo(x, yTop);
    let xx=x, yy=yTop;
    for (let i=0; i<turns*2; i++){
      yy += seg;
      xx = x + (i%2===0 ? -amp : amp);
      ctx.lineTo(xx, yy);
    }
    ctx.lineTo(x, yBot);
    ctx.stroke();
  }
  function drawDamper(x, yTop, yBot){
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 2;
    const mid = (yTop + yBot)/2;
    ctx.beginPath(); ctx.moveTo(x,yTop); ctx.lineTo(x, mid-30); ctx.stroke();
    ctx.beginPath(); ctx.rect(x-18, mid-30, 36, 24); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, mid-6); ctx.lineTo(x, yBot); ctx.stroke();
  }

  const SCENE_TOP_SHIFT = 26;

  function drawSchematic(sim, tNow, zNow){
    const w = canv.width, h = canv.height;

    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--panel").trim() || "#d9d9d9";
    ctx.fillRect(0,0,w,h);

    ctx.save();
    ctx.translate(0, SCENE_TOP_SHIFT);

    const xMid = Math.round(w*0.72);

    // Ground line
    const groundY = Math.round(h*0.86);
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(Math.round(w*0.48), groundY);
    ctx.lineTo(Math.round(w*0.94), groundY);
    ctx.stroke();

    // Base block: fixed (grounded)
    const baseW = 210, baseH = 70;
    const baseY = groundY - baseH - 10;
    const xBase = xMid - baseW/2;

    ctx.fillStyle = "#b9c7df";
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 3;
    roundRect(xBase, baseY, baseW, baseH, 16);

    // Mass block (relative motion only)
    const bw = 170, bh = 76;
    const xMass = xMid - bw/2;

    const gap0 = 120; // longer spring/damper
    const massY0 = baseY - gap0 - bh;

    // scale z(t) to pixels using sim span
    let zScale = 1;
    if (sim){
      const zSpan = Math.max(1e-9, ...sim.z.map(v=>Math.abs(v)));
      zScale = (0.22*h)/zSpan;
    }

    const massY = massY0 + (sim ? (zNow * zScale) : 0);

    const yAttachBase = baseY - 6;
    const yAttachMass = massY + bh + 6;

    const xDamper = Math.round(xMid - 42);
    const xSpring = Math.round(xMid + 42);
    drawDamper(xDamper, yAttachMass, yAttachBase);
    drawSpring(xSpring, yAttachMass, yAttachBase);

    ctx.fillStyle = "#cfd5dd";
    ctx.strokeStyle = "#111827";
    ctx.lineWidth = 3;
    roundRect(xMass, massY, bw, bh, 18);

    ctx.fillStyle = "#111827";
    ctx.font = "700 13px Arial, Helvetica, sans-serif";
    ctx.fillText("W", xMass + 12, massY + 22);
    ctx.font = "700 12px Arial, Helvetica, sans-serif";
    ctx.fillText("base", xBase + 12, baseY + 22);

    // Timer: left-ish, slightly larger
    ctx.font = "800 16px Arial, Helvetica, sans-serif";
    ctx.fillText("t = " + fmt(tNow,4) + " s", Math.round(w*0.30), Math.round(h*0.12));

    ctx.restore();
  }

  // ---------- Live recompute / UI ----------
  let simReady = null;
  let debounceTimer = null;


function updateRandomUI(){
  const isRand = (inp.shape.value === "random");

  psdPanel.style.display = isRand ? "block" : "none";
  buildRandomBtn.disabled = !isRand;

  psdStatus.textContent = !isRand
    ? "Provide 2–5 points, increasing frequency. Click “Build Random g(t)” to preview and arm the base input."
    : (randomInput
        ? "Random input is built and armed. Click Run to simulate using this base acceleration."
        : "Provide 2–5 points, increasing frequency. Click “Build Random g(t)” to preview and arm the base input.");
}




  function recomputeLive(){
    // Do not compute full sim here; just update summary KPIs and initial schematic.
    simReady = simulateFromInputs();

    // If random needed, just show KPIs and keep schematic at rest.
    writeSummary(simReady);
    drawSchematic(simReady && !simReady.__needsRandom ? simReady : null, 0, 0);
  }

  function requestRecompute(){
    if (anim.running) return;
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(recomputeLive, 120);
  }

  Object.values(inp).forEach(el => {
    el.addEventListener("input", requestRecompute);
    el.addEventListener("change", ()=>{
      if (el === inp.shape){
        updateRandomUI();
      }
      requestRecompute();
    });
  });

inp.shape.addEventListener("input", () => { updateRandomUI(); requestRecompute(); });
inp.shape.addEventListener("change", () => { updateRandomUI(); requestRecompute(); });


  // PSD inputs should trigger status update (but not force rebuild)
  ["f1","s1","f2","s2","f3","s3","f4","s4","f5","s5"].forEach(id=>{
    $(id).addEventListener("input", ()=>{
      if (inp.shape.value === "random"){
        psdStatus.textContent = randomInput
          ? "PSD edited. Click “Build Random g(t)” again to rebuild/refresh the random time history."
          : "Provide 2–5 points, increasing frequency. Click “Build Random g(t)” to preview and arm the base input.";
      }
    });
  });

  // ---------- Build Random button ----------
  buildRandomBtn.addEventListener("click", ()=>{
    if (anim.running) return;

    const kpi = computeKPI();
    if (!kpi){
      psdStatus.textContent = "Enter valid W, k, and g before building Random input.";
      return;
    }

    const res = buildRandomTimeHistory(kpi);
    if (!res.ok){
      psdStatus.textContent = res.msg;
      randomInput = null;
      recomputeLive();
      return;
    }

    randomInput = {
      t: res.t,
      abase: res.abase,
      dt: res.dt,
      tStop: res.tStop,
      gMaxB: res.gMaxB,
      meta: res.meta
    };

    // Preview g(t) on chart (base only)
    chart.data.labels = randomInput.t.map(x => x.toFixed(4));
    chart.data.datasets[0].data = randomInput.abase;
    chart.data.datasets[1].data = [];
    chart.update();

    psdStatus.textContent = `Random input built and armed. dt=${fmt(randomInput.dt,4)} s, duration=${fmt(randomInput.tStop,3)} s, base g max=${fmt(randomInput.gMaxB,2)} g. Click Run to simulate.`;
    recomputeLive();
  });

  // ---------- Animation ----------
  function setButtons(running, paused){
    btnRun.disabled = running && !paused;
    btnPause.disabled = !running;
    btnStop.disabled = !running;
    btnPause.textContent = paused ? "Resume" : "Pause";
  }

  let anim = { running:false, paused:false, idx:0, t0:0 };
  let raf = null;

  function updateChartTo(idx){
    chart.data.labels = simReady.t.slice(0, idx+1).map(x => x.toFixed(4));
    chart.data.datasets[0].data = simReady.abase.slice(0, idx+1);
    chart.data.datasets[1].data = simReady.aweight.slice(0, idx+1);
    chart.update();
  }

  function start(){
    lastRunInputs = {
      W:+inp.W.value, k:+inp.k.value, c:+inp.c.value, g:+inp.g.value,
      Gpk:+inp.Gpk.value, Tp:+inp.Tp.value, dt:+inp.dt.value, shape:inp.shape.value
    };

    simReady = simulateFromInputs();
    if (!simReady){
      recomputeLive();
      return;
    }
    if (simReady.__needsRandom){
      alert("Random is selected. Click “Build Random g(t)” first to generate the base acceleration time history.");
      return;
    }

    chart.data.labels = [];
    chart.data.datasets[0].data = [];
    chart.data.datasets[1].data = [];
    chart.update();

    anim.running = true;
    anim.paused = false;
    anim.idx = 0;
    anim.t0 = performance.now();
    setButtons(true,false);

    const step = () => {
      if (!anim.running) return;

      const spd = +speed.value;
      const now = performance.now();

      if (!anim.paused){
        const dtSec = ((now - anim.t0)/1000) * spd;
        anim.t0 = now;

        const tTarget = simReady.t[anim.idx] + dtSec;
        while (anim.idx < simReady.t.length-1 && simReady.t[anim.idx] < tTarget){
          anim.idx++;
        }

        if (anim.idx >= simReady.t.length-1){
          anim.idx = simReady.t.length-1;
          updateChartTo(anim.idx);
          drawSchematic(simReady, simReady.t[anim.idx], simReady.z[anim.idx]);
          stop();
          return;
        }
      } else {
        anim.t0 = now;
      }

      updateChartTo(anim.idx);
      drawSchematic(simReady, simReady.t[anim.idx], simReady.z[anim.idx]);

      raf = requestAnimationFrame(step);
    };

    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(step);
  }

  function stop(){
    anim.running = false;
    anim.paused = false;
    setButtons(false,false);
    cancelAnimationFrame(raf);
    raf = null;

    if (simReady && !simReady.__needsRandom){
      updateChartTo(simReady.t.length-1);
      drawSchematic(simReady, simReady.t.at(-1), simReady.z.at(-1));
    }
  }

  function hardReset(){
    anim.running = false;
    anim.paused = false;
    setButtons(false,false);
    cancelAnimationFrame(raf);
    raf = null;

    const src = lastRunInputs || defaults;

    inp.W.value = src.W;
    inp.k.value = src.k;
    inp.c.value = src.c;
    inp.g.value = src.g;
    inp.Gpk.value = src.Gpk;
    inp.Tp.value = src.Tp;
    inp.dt.value = src.dt;
    inp.shape.value = src.shape;

    // do not wipe randomInput on reset (keeps it “armed” unless user rebuilds),
    // but update UI visibility.
    updateRandomUI();

    chart.data.labels = [];
    chart.data.datasets[0].data = [];
    chart.data.datasets[1].data = [];
    chart.update();

    recomputeLive();
  }

  btnRun.addEventListener("click", start);
  btnPause.addEventListener("click", () => {
    if (!anim.running) return;
    anim.paused = !anim.paused;
    setButtons(true, anim.paused);
  });
  btnStop.addEventListener("click", stop);
  btnReset.addEventListener("click", hardReset);

  speed.addEventListener("input", () => speedLbl.textContent = (+speed.value).toFixed(1) + "×");

  // init
  speedLbl.textContent = (+speed.value).toFixed(1) + "×";
  updateRandomUI();
  recomputeLive();
})();
</script>
</body>
</html>




